#
# filter-select
#
# filter and select
#
# using filter-select, you can incrementaly filter candidate
# and select one with C-n/C-p keys.
#
# press enter to put selected candidate into edit buffer.
# C-g to abort selection.

FILTER_SELECT_HIGHLIGHT=${FILTER_SELECT_HIGHLIGHT:-fg=magenta,underline}

function filter-select() {
    emulate -L zsh
    setopt local_options extended_glob

    # save ZLE related variables
    local orig_lbuffer="${LBUFFER}"
    local orig_rbuffer="${RBUFFER}"
    local orig_predisplay="${PREDISPLAY}"
    local orig_postdisplay="${POSTDISPLAY}"
    local -a orig_region_highlight
    orig_region_highlight=("${region_highlight[@]}")

    local key cand lines selected cand_disp last_buffer=''
    local -a displays matched_cand_keys
    local -A candidates
    integer i bottom_lines cursor_line=1 display_head_line=1 cand_num disp_num offset display_bottom_line selected_num

    integer i=0
    for cand in "$@"; do
        (( i++ ))
        candidates+=( $i "${cand}" )
    done

    cand_num="${#candidates}"
    matched_cand_keys=("${(onk@)candidates}")

    key=''

    _filter-select-update-lines

    while [[ '#key' -ne '#\\r' && '#key' -ne '#\\n' &&
             '#key' -ne '#\\C-g' ]]; do

        # cursor が移動できる一番下の行
        # ${lines} か ${cand_num} の小さい方を使う
        if (( lines < cand_num )); then
            bottom_lines="${lines}"
        else
            bottom_lines="${cand_num}"
        fi

        if [[ '#key' -eq '#\\C-h' || '#key' -eq '#\\C-?' ]]; then
            zle backward-delete-char
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-n' ]]; then
            (( cursor_line++ ))

        elif [[ '#key' -eq '#\\C-p' ]]; then
            (( cursor_line-- ))

        elif [[ '#key' -eq '#\\C-f' ]]; then
            zle forward-char

        elif [[ '#key' -eq '#\\C-b' ]]; then
            zle backward-char

        elif [[ '#key' -eq '#\\C-a' ]]; then
            zle beginning-of-line

        elif [[ '#key' -eq '#\\C-e' ]]; then
            zle end-of-line

        elif [[ '#key' -eq '#\\C-w' ]]; then
            zle backward-kill-word
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-k' ]]; then
            zle kill-line
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-u' ]]; then
            zle kill-whole-line
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-v' ]]; then
            (( cursor_line += lines ))

        elif [[ '#key' -eq '#\\e' ]]; then
            # M-...
            read -k key
            case "${key}" in
                'v')
                    (( cursor_line -= lines ))
                    ;;
                '<')
                    (( cursor_line = 1 ))
                    (( display_head_line = 1 ))
                    ;;
                '>')
                    (( cursor_line = cand_num ))
                    ;;
                '[')
                    # cursor keys
                    read -k key
                    case "${key}" in
                        'A')
                            # up
                            (( cursor_line-- ))
                            ;;
                        'B')
                            # down
                            (( cursor_line++ ))
                            ;;
                        'C')
                            # right
                            zle forward-char
                            ;;
                        'D')
                            # left
                            zle backward-char
                            ;;
                    esac
            esac

        else
            LBUFFER="${LBUFFER}${key}"
            _filter-select-reset
        fi

        if (( cursor_line < 1 )); then
            (( display_head_line -= 1 - cursor_line ))
            if (( display_head_line < 1 )); then
                (( display_head_line = 1 ))
            fi
            (( cursor_line = 1 ))

        elif (( bottom_lines == 0 )); then
            (( display_head_line = 1 ))
            (( cursor_line = 1 ))

        elif (( cursor_line > bottom_lines )); then
            (( display_head_line += cursor_line - bottom_lines ))
            if (( display_head_line > cand_num - lines + 1 )); then
                (( display_head_line = cand_num - lines + 1 ))
            fi
            (( cursor_line = bottom_lines ))
        fi

        if (( ! PENDING )); then
            region_highlight=("${orig_region_highlight[@]}")

            displays=()
            offset="${#BUFFER}"

            selected=""
            selected_num=0

            display_bottom_line=$(( display_head_line + lines))

            if [[ "${BUFFER}" != "${last_buffer}" ]]; then
                if [[ -n "${BUFFER}" ]]; then
                    matched_cand_keys=("${(onk@)candidates[(R)*${BUFFER}*]}")
                else
                    matched_cand_keys=("${(onk@)candidates}")
                fi
                last_buffer="${BUFFER}"
            fi

            # nums patters matched
            cand_num="${#matched_cand_keys}"

            # nums displayed
            disp_num=0

            for i in "${(@)matched_cand_keys[${display_head_line},$(( display_bottom_line - 1 ))]}"; do
                (( disp_num++ ))
                cand="${candidates[$i]}"

                if (( ${(m)#cand} > COLUMNS - 1 )); then
                    # strip long line
                    cand_disp="${(mr:$(( COLUMNS - 6 )):::::)cand} ..."
                else
                    cand_disp="${cand}"
                fi

                displays+="${cand_disp}"

                if [[ -n "${BUFFER}" && "${cand_disp}" == (#b)*(${~BUFFER})* ]]; then
                    # highlight matched words
                    region_highlight+="$(( offset + mbegin[1] )) $(( offset + mend[1] + 1 )) ${FILTER_SELECT_HIGHLIGHT}"
                fi

                if (( disp_num == cursor_line )); then
                    region_highlight+="${offset} $(( offset + ${#cand_disp} + 1 )) standout"
                    selected="${cand}"
                    (( selected_num = display_head_line + disp_num - 1 ))
                fi

                (( offset += ${#cand_disp} + 1 )) # +1 -> \n
            done

            POSTDISPLAY=$'\n'"${(F)displays}"$'\n'"[${selected_num}/${cand_num}]"
            zle -R

        fi

        read -k key
    done

    if [[ '#key' -eq '#\\r' || '#key' -eq '#\\n' ]]; then
        LBUFFER="${selected}"
        RBUFFER=""

    elif [[ '#key' -eq '#\\C-g' ]]; then
        LBUFFER="${orig_lbuffer}"
        RBUFFER="${orig_rbuffer}"
    fi

    PREDISPLAY="${orig_predisplay}"
    POSTDISPLAY="${orig_postdisplay}"
    region_highlight=("${orig_region_highlight[@]}")
    zle -Rc
    zle reset-prompt
}

function _filter-select-update-lines() {
    # XXX: this function override ${lines}
    #      that define as local in filter-select

    local _tmp_postdisplay="${POSTDISPLAY}"
    # to re-calculate ${BUFFERLINES}
    POSTDISPLAY=""
    zle -R

    # lines that can be used to display candidates
    # -1 for current/total number display area
    (( lines = LINES - BUFFERLINES - 1 ))

    POSTDISPLAY="${_tmp_postdisplay}"
    zle -R
}

function _filter-select-reset() {
    display_head_line=1
    cursor_line=1
    _filter-select-update-lines
}

filter-select "$@"
