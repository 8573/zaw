#
# filter-select
#
# using filter-select, you can incrementaly filter candidate
# and select one with ^N/^P keys.
#
# press enter for filter-select to update $reply and return 0,
# press meta (alt) + enter to update $reply but return 1,
# and press ^C or ^G not to update $reply and return 1.
#
#
# usage:
#   filter-select [-A assoc-array-name] [-r] [--] [arg]...
#
# key binds:
#   enter:         update $reply and return
#   meta + enter:  update $reply but return 1
#   ^C, ^G:        return 0
#   ^H, backspace: backward-delete-char
#   ^F, right key: forward-char
#   ^B, left key:  backward-char
#   ^A:            beginning-of-line
#   ^E:            end-of-line
#   ^W:            backward-kill-word
#   ^K:            kill-line
#   ^U:            kill-whole-line
#   ^N, down key:  select next item
#   ^P, up key:    select previous item
#   ^V:            page down
#   ^[V:           page up
#   ^[<:           select first item
#   ^[>:           select last item
#
# available zstyles:
#   ':filter-select:highlight' selected
#   ':filter-select:highlight' matched
#   ':filter-select' max-lines
#
#   example:
#     zstyle ':filter-select:highlight' matched fg=yellow,standout
#     zstyle ':filter-select' max-lines 10 # use 10 lines for filter-select
#     zstyle ':filter-select' max-lines -10 # use $LINES - 10 for filter-select

function filter-select() {
    emulate -L zsh
    setopt local_options extended_glob

    # save ZLE related variables
    local orig_lbuffer="${LBUFFER}"
    local orig_rbuffer="${RBUFFER}"
    local orig_predisplay="${PREDISPLAY}"
    local orig_postdisplay="${POSTDISPLAY}"
    local -a orig_region_highlight
    orig_region_highlight=("${region_highlight[@]}")

    local key cand lines selected cand_disp last_buffer='' opt pattern msg
    local -a displays matched_cand_keys match mbegin mend
    local -A candidates
    integer i bottom_lines cursor_line=1 display_head_line=1 cand_num disp_num offset display_bottom_line selected_num rev=0 ret=0

    local hi_selected hi_matched
    zstyle -s ':filter-select:highlight' selected hi_selected || hi_selected='standout'
    zstyle -s ':filter-select:highlight' matched hi_matched || hi_matched='fg=magenta,underline'

    integer max_lines
    zstyle -s ':filter-select' max-lines max_lines || max_lines=0

    candidates=()

    while getopts 'A:r' opt; do
        case "${opt}" in
            A)
                # copy input assc array
                candidates=("${(@kvP)${OPTARG}}")
                ;;
            r)
                # reverse ordering
                rev=1
                ;;
        esac
    done

    if (( OPTIND > 1 )); then
        shift $(( OPTIND - 1 ))
    fi
    integer i=0
    for cand in "$@"; do
        (( i++ ))
        candidates+=( $i "${cand}" )
    done

    cand_num="${#candidates}"
    matched_cand_keys=("${(onk@)candidates}")
    if (( rev )); then
        matched_cand_keys=("${(Oa@)matched_cand_keys}")
    fi

    key=''

    _filter-select-reset

    while [[ '#key' -ne '#\\r' && '#key' -ne '#\\n' &&
             '#key' -ne '#\\C-g' ]]; do

        if [[ '#key' -eq '#\\C-h' || '#key' -eq '#\\C-?' ]]; then
            zle backward-delete-char
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-n' ]]; then
            (( cursor_line++ ))

        elif [[ '#key' -eq '#\\C-p' ]]; then
            (( cursor_line-- ))

        elif [[ '#key' -eq '#\\C-f' ]]; then
            zle forward-char

        elif [[ '#key' -eq '#\\C-b' ]]; then
            zle backward-char

        elif [[ '#key' -eq '#\\C-a' ]]; then
            zle beginning-of-line

        elif [[ '#key' -eq '#\\C-e' ]]; then
            zle end-of-line

        elif [[ '#key' -eq '#\\C-w' ]]; then
            zle backward-kill-word
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-k' ]]; then
            zle kill-line
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-u' ]]; then
            zle kill-whole-line
            _filter-select-reset

        elif [[ '#key' -eq '#\\C-v' ]]; then
            (( cursor_line += bottom_lines ))

        elif [[ '#key' -eq '#\\e' ]]; then
            # M-...
            read -k key
            if [[ '#key' -eq '#\\r' || '#key' -eq '#\\n' ]]; then
                # meta + enter
                # return 1
                ret=1
                break
            fi
            case "${key}" in
                'v')
                    (( cursor_line -= bottom_lines ))
                    ;;
                '<')
                    (( cursor_line = 1 ))
                    (( display_head_line = 1 ))
                    ;;
                '>')
                    (( cursor_line = cand_num ))
                    ;;
                '[')
                    # cursor keys
                    read -k key
                    case "${key}" in
                        'A')
                            # up
                            (( cursor_line-- ))
                            ;;
                        'B')
                            # down
                            (( cursor_line++ ))
                            ;;
                        'C')
                            # right
                            zle forward-char
                            ;;
                        'D')
                            # left
                            zle backward-char
                            ;;
                    esac
            esac

        else
            LBUFFER="${LBUFFER}${key}"
            _filter-select-reset
        fi

        if (( cursor_line < 1 )); then
            (( display_head_line -= 1 - cursor_line ))
            if (( display_head_line < 1 )); then
                (( display_head_line = 1 ))
            fi
            (( cursor_line = 1 ))

        elif (( bottom_lines == 0 )); then
            (( display_head_line = 1 ))
            (( cursor_line = 1 ))

        elif (( cursor_line > bottom_lines )); then
            (( display_head_line += cursor_line - bottom_lines ))
            if (( display_head_line > cand_num - bottom_lines + 1 )); then
                (( display_head_line = cand_num - bottom_lines + 1 ))
            fi
            (( cursor_line = bottom_lines ))
        fi

        if (( ! PENDING )); then
            region_highlight=("${orig_region_highlight[@]}")

            displays=()
            offset="${#BUFFER}"

            selected=""
            selected_num=0

            if [[ "${BUFFER}" != "${last_buffer}" ]]; then
                if [[ -n "${BUFFER}" ]]; then
                    # escape "(", ")", "[", "]" and "#" to avoid crash
                    pattern="${BUFFER//(#m)[()[\]#]/\\${MATCH}}"

                    matched_cand_keys=("${(onk@)candidates[(R)*${pattern}*]}")
                else
                    matched_cand_keys=("${(onk@)candidates}")
                fi
                if (( rev )); then
                    matched_cand_keys=("${(Oa@)matched_cand_keys}")
                fi
                last_buffer="${BUFFER}"
            fi

            # nums pattern matched
            cand_num="${#matched_cand_keys}"

            # nums displayed
            disp_num=0

            _filter-select-update-bottom-lines
            display_bottom_line=$(( display_head_line + bottom_lines))

            for i in "${(@)matched_cand_keys[${display_head_line},$(( display_bottom_line - 1 ))]}"; do
                (( disp_num++ ))
                cand="${candidates[$i]}"

                cand_disp="${cand}"

                # escape \r\n\t\
                cand_disp="${cand_disp//\\/\\\\}"
                cand_disp="${cand_disp//$'\n'/\\n}"
                cand_disp="${cand_disp//$'\r'/\\r}"
                cand_disp="${cand_disp//$'\t'/\\t}"

                if (( ${(m)#cand_disp} > COLUMNS - 1 )); then
                    # strip long line
                    cand_disp="${(mr:$(( COLUMNS - 6 )):::::)cand_disp} ..."
                fi

                displays+="${cand_disp}"

                if [[ -n "${BUFFER}" && "${cand_disp}" == (#b)*(${~pattern})* ]]; then
                    # highlight matched words
                    region_highlight+="$(( offset + mbegin[1] )) $(( offset + mend[1] + 1 )) ${hi_matched}"
                fi

                if (( disp_num == cursor_line )); then
                    region_highlight+="${offset} $(( offset + ${#cand_disp} + 1 )) ${hi_selected}"
                    selected="${cand}"
                    (( selected_num = display_head_line + disp_num - 1 ))
                fi

                (( offset += ${#cand_disp} + 1 )) # +1 -> \n
            done

            if (( ${#displays} == 0 )); then
                msg='pattern not found'
                displays=( "${msg}" )
                region_highlight+="${offset} $(( offset + ${#msg} + 1 )) fg=white,bg=red"
            fi

            POSTDISPLAY=$'\n'"${(F)displays}"$'\n'"[${selected_num}/${cand_num}]"
            zle -R

        fi

        read -k key

        if [[ $? != 0 ]]; then
            # maybe ^C
            key=''
            break
        fi
    done

    if [[ '#key' -eq '#\\r' || '#key' -eq '#\\n' ]]; then
        reply="${selected}"

    elif [[ -z "${key}" || '#key' -eq '#\\C-g' ]]; then
        ret=1
    fi

    LBUFFER="${orig_lbuffer}"
    RBUFFER="${orig_rbuffer}"
    PREDISPLAY="${orig_predisplay}"
    POSTDISPLAY="${orig_postdisplay}"
    region_highlight=("${orig_region_highlight[@]}")
    zle -Rc
    zle reset-prompt

    return $ret
}

function _filter-select-update-lines() {
    # XXX: this function override ${lines}
    #      that define as local in filter-select

    local _tmp_postdisplay="${POSTDISPLAY}"
    # to re-calculate ${BUFFERLINES}
    POSTDISPLAY=""
    zle -R

    # lines that can be used to display candidates
    # -1 for current/total number display area
    (( lines = LINES - BUFFERLINES - 1 ))

    POSTDISPLAY="${_tmp_postdisplay}"
    zle -R
}

function _filter-select-update-bottom-lines() {
    # cursor が移動できる一番下の行
    # ${max_lines} か ${lines} か ${cand_num} の小さい方を使う
    if (( max_lines > 0 && max_lines < lines )); then
        (( bottom_lines = max_lines ))
    elif (( max_lines < 0 )); then
        (( bottom_lines = lines + max_lines ))
    else
        (( bottom_lines = lines ))
    fi

    if (( cand_num < bottom_lines )); then
        (( bottom_lines = cand_num ))
    fi

    if (( bottom_lines < 1 )); then
        (( bottom_lines = 1 ))
    fi
}

function _filter-select-reset() {
    display_head_line=1
    cursor_line=1
    _filter-select-update-lines
    _filter-select-update-bottom-lines
}

filter-select "$@"
